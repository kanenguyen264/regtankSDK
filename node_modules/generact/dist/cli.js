#!/usr/bin/env node
'use strict';

var _path = require('path');

var _chalk = require('chalk');

var _meow = require('meow');

var _meow2 = _interopRequireDefault(_meow);

var _inquirer = require('inquirer');

var _inquirer2 = _interopRequireDefault(_inquirer);

var _inquirerAutocompletePrompt = require('inquirer-autocomplete-prompt');

var _inquirerAutocompletePrompt2 = _interopRequireDefault(_inquirerAutocompletePrompt);

var _ora = require('ora');

var _ora2 = _interopRequireDefault(_ora);

var _prompts = require('./prompts');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
/* eslint-disable no-console */


const cli = (0, _meow2.default)(`
  Usage
    $ generact [path]

  Options
    --root Sets the root path to scan for component files.

  Examples
    $ generact
    $ generact src/components/Button.js
    $ generact --root src/components
`);

const performReplication = (() => {
  var _ref = _asyncToGenerator(function* (path) {
    const originalName = (0, _utils.getComponentName)(path);
    const absolutePath = (0, _path.isAbsolute)(path) ? path : (0, _path.join)(process.cwd(), path);
    const relativePath = (0, _path.relative)(process.cwd(), absolutePath);
    const originalFolder = (0, _utils.getComponentFolder)(relativePath);

    const answers = yield _inquirer2.default.prompt([(0, _prompts.name)(originalName), (0, _prompts.folder)(originalFolder)]);

    (0, _utils.replicate)(path, answers);
  });

  return function performReplication(_x) {
    return _ref.apply(this, arguments);
  };
})();

const scan = (() => {
  var _ref2 = _asyncToGenerator(function* (root = process.cwd()) {
    const absoluteRoot = (0, _path.isAbsolute)(root) ? root : (0, _path.join)(process.cwd(), root);
    const spinner = (0, _ora2.default)(`Scanning ${(0, _chalk.green)(absoluteRoot)} for React component files...`).start();
    const files = yield (0, _utils.getComponentFiles)(absoluteRoot);
    spinner.stop();

    if (!files.length) {
      console.log(_chalk.red.bold('No components found! :(\n'));
      console.log(`Make sure you are running ${(0, _chalk.cyan)('generact')} inside a React-like project directory or using ${(0, _chalk.green)('root')} option:\n`);
      console.log(`    ${(0, _chalk.cyan)('$ generact')} ${(0, _chalk.green)('--root relative/or/absolute/path/to/any/react/project')}\n`);
      console.log(`If you are already doing that, it means that ${(0, _chalk.cyan)('generact')} could not find your React component files automagically.`);
      console.log('In this case, you can explicitly pass the component path to replicate:\n');
      console.log(`    ${(0, _chalk.cyan)('$ generact')} ${(0, _chalk.green)('relative/or/absolute/path/to/my/react/component.js')}\n`);
      return process.exit(1);
    }

    _inquirer2.default.registerPrompt('autocomplete', _inquirerAutocompletePrompt2.default);
    const answers = yield _inquirer2.default.prompt([(0, _prompts.component)(files)]);
    return answers.component;
  });

  return function scan() {
    return _ref2.apply(this, arguments);
  };
})();

if (cli.input.length) {
  performReplication(cli.input[0]);
} else {
  scan(cli.flags.root).then(performReplication);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGkuanMiXSwibmFtZXMiOlsiY2xpIiwicGVyZm9ybVJlcGxpY2F0aW9uIiwicGF0aCIsIm9yaWdpbmFsTmFtZSIsImFic29sdXRlUGF0aCIsInByb2Nlc3MiLCJjd2QiLCJyZWxhdGl2ZVBhdGgiLCJvcmlnaW5hbEZvbGRlciIsImFuc3dlcnMiLCJpbnF1aXJlciIsInByb21wdCIsInNjYW4iLCJyb290IiwiYWJzb2x1dGVSb290Iiwic3Bpbm5lciIsInN0YXJ0IiwiZmlsZXMiLCJzdG9wIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInJlZCIsImJvbGQiLCJleGl0IiwicmVnaXN0ZXJQcm9tcHQiLCJhdXRvY29tcGxldGUiLCJjb21wb25lbnQiLCJpbnB1dCIsImZsYWdzIiwidGhlbiJdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7OztBQVJBOzs7QUFlQSxNQUFNQSxNQUFNLG9CQUFNOzs7Ozs7Ozs7OztDQUFOLENBQVo7O0FBYUEsTUFBTUM7QUFBQSwrQkFBcUIsV0FBT0MsSUFBUCxFQUFnQjtBQUN6QyxVQUFNQyxlQUFlLDZCQUFpQkQsSUFBakIsQ0FBckI7QUFDQSxVQUFNRSxlQUFlLHNCQUFXRixJQUFYLElBQW1CQSxJQUFuQixHQUEwQixnQkFBS0csUUFBUUMsR0FBUixFQUFMLEVBQW9CSixJQUFwQixDQUEvQztBQUNBLFVBQU1LLGVBQWUsb0JBQVNGLFFBQVFDLEdBQVIsRUFBVCxFQUF3QkYsWUFBeEIsQ0FBckI7QUFDQSxVQUFNSSxpQkFBaUIsK0JBQW1CRCxZQUFuQixDQUF2Qjs7QUFFQSxVQUFNRSxVQUFVLE1BQU1DLG1CQUFTQyxNQUFULENBQWdCLENBQ3BDLG1CQUFLUixZQUFMLENBRG9DLEVBRXBDLHFCQUFPSyxjQUFQLENBRm9DLENBQWhCLENBQXRCOztBQUtBLDBCQUFVTixJQUFWLEVBQWdCTyxPQUFoQjtBQUNELEdBWks7O0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBTjs7QUFjQSxNQUFNRztBQUFBLGdDQUFPLFdBQU9DLE9BQU9SLFFBQVFDLEdBQVIsRUFBZCxFQUFnQztBQUMzQyxVQUFNUSxlQUFlLHNCQUFXRCxJQUFYLElBQW1CQSxJQUFuQixHQUEwQixnQkFBS1IsUUFBUUMsR0FBUixFQUFMLEVBQW9CTyxJQUFwQixDQUEvQztBQUNBLFVBQU1FLFVBQVUsbUJBQUssWUFBVyxrQkFBTUQsWUFBTixDQUFvQiwrQkFBcEMsRUFBb0VFLEtBQXBFLEVBQWhCO0FBQ0EsVUFBTUMsUUFBUSxNQUFNLDhCQUFrQkgsWUFBbEIsQ0FBcEI7QUFDQUMsWUFBUUcsSUFBUjs7QUFFQSxRQUFJLENBQUNELE1BQU1FLE1BQVgsRUFBbUI7QUFDakJDLGNBQVFDLEdBQVIsQ0FBWUMsV0FBSUMsSUFBSixDQUFTLDJCQUFULENBQVo7QUFDQUgsY0FBUUMsR0FBUixDQUFhLDZCQUE0QixpQkFBSyxVQUFMLENBQWlCLG1EQUFrRCxrQkFBTSxNQUFOLENBQWMsWUFBMUg7QUFDQUQsY0FBUUMsR0FBUixDQUFhLE9BQU0saUJBQUssWUFBTCxDQUFtQixJQUFHLGtCQUFNLHVEQUFOLENBQStELElBQXhHO0FBQ0FELGNBQVFDLEdBQVIsQ0FBYSxnREFBK0MsaUJBQUssVUFBTCxDQUFpQiwyREFBN0U7QUFDQUQsY0FBUUMsR0FBUixDQUFZLDBFQUFaO0FBQ0FELGNBQVFDLEdBQVIsQ0FBYSxPQUFNLGlCQUFLLFlBQUwsQ0FBbUIsSUFBRyxrQkFBTSxvREFBTixDQUE0RCxJQUFyRztBQUNBLGFBQU9oQixRQUFRbUIsSUFBUixDQUFhLENBQWIsQ0FBUDtBQUNEOztBQUVEZCx1QkFBU2UsY0FBVCxDQUF3QixjQUF4QixFQUF3Q0Msb0NBQXhDO0FBQ0EsVUFBTWpCLFVBQVUsTUFBTUMsbUJBQVNDLE1BQVQsQ0FBZ0IsQ0FBQyx3QkFBVU0sS0FBVixDQUFELENBQWhCLENBQXRCO0FBQ0EsV0FBT1IsUUFBUWtCLFNBQWY7QUFDRCxHQW5CSzs7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFOOztBQXFCQSxJQUFJM0IsSUFBSTRCLEtBQUosQ0FBVVQsTUFBZCxFQUFzQjtBQUNwQmxCLHFCQUFtQkQsSUFBSTRCLEtBQUosQ0FBVSxDQUFWLENBQW5CO0FBQ0QsQ0FGRCxNQUVPO0FBQ0xoQixPQUFLWixJQUFJNkIsS0FBSixDQUFVaEIsSUFBZixFQUFxQmlCLElBQXJCLENBQTBCN0Isa0JBQTFCO0FBQ0QiLCJmaWxlIjoiY2xpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5pbXBvcnQgeyBqb2luLCByZWxhdGl2ZSwgaXNBYnNvbHV0ZSB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBjeWFuLCBncmVlbiwgcmVkIH0gZnJvbSAnY2hhbGsnXG5pbXBvcnQgbWVvdyBmcm9tICdtZW93J1xuaW1wb3J0IGlucXVpcmVyIGZyb20gJ2lucXVpcmVyJ1xuaW1wb3J0IGF1dG9jb21wbGV0ZSBmcm9tICdpbnF1aXJlci1hdXRvY29tcGxldGUtcHJvbXB0J1xuaW1wb3J0IG9yYSBmcm9tICdvcmEnXG5pbXBvcnQgeyBjb21wb25lbnQsIG5hbWUsIGZvbGRlciB9IGZyb20gJy4vcHJvbXB0cydcbmltcG9ydCB7XG4gIGdldENvbXBvbmVudE5hbWUsXG4gIGdldENvbXBvbmVudEZvbGRlcixcbiAgZ2V0Q29tcG9uZW50RmlsZXMsXG4gIHJlcGxpY2F0ZSxcbn0gZnJvbSAnLi91dGlscydcblxuY29uc3QgY2xpID0gbWVvdyhgXG4gIFVzYWdlXG4gICAgJCBnZW5lcmFjdCBbcGF0aF1cblxuICBPcHRpb25zXG4gICAgLS1yb290IFNldHMgdGhlIHJvb3QgcGF0aCB0byBzY2FuIGZvciBjb21wb25lbnQgZmlsZXMuXG5cbiAgRXhhbXBsZXNcbiAgICAkIGdlbmVyYWN0XG4gICAgJCBnZW5lcmFjdCBzcmMvY29tcG9uZW50cy9CdXR0b24uanNcbiAgICAkIGdlbmVyYWN0IC0tcm9vdCBzcmMvY29tcG9uZW50c1xuYClcblxuY29uc3QgcGVyZm9ybVJlcGxpY2F0aW9uID0gYXN5bmMgKHBhdGgpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWxOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShwYXRoKVxuICBjb25zdCBhYnNvbHV0ZVBhdGggPSBpc0Fic29sdXRlKHBhdGgpID8gcGF0aCA6IGpvaW4ocHJvY2Vzcy5jd2QoKSwgcGF0aClcbiAgY29uc3QgcmVsYXRpdmVQYXRoID0gcmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgYWJzb2x1dGVQYXRoKVxuICBjb25zdCBvcmlnaW5hbEZvbGRlciA9IGdldENvbXBvbmVudEZvbGRlcihyZWxhdGl2ZVBhdGgpXG5cbiAgY29uc3QgYW5zd2VycyA9IGF3YWl0IGlucXVpcmVyLnByb21wdChbXG4gICAgbmFtZShvcmlnaW5hbE5hbWUpLFxuICAgIGZvbGRlcihvcmlnaW5hbEZvbGRlciksXG4gIF0pXG5cbiAgcmVwbGljYXRlKHBhdGgsIGFuc3dlcnMpXG59XG5cbmNvbnN0IHNjYW4gPSBhc3luYyAocm9vdCA9IHByb2Nlc3MuY3dkKCkpID0+IHtcbiAgY29uc3QgYWJzb2x1dGVSb290ID0gaXNBYnNvbHV0ZShyb290KSA/IHJvb3QgOiBqb2luKHByb2Nlc3MuY3dkKCksIHJvb3QpXG4gIGNvbnN0IHNwaW5uZXIgPSBvcmEoYFNjYW5uaW5nICR7Z3JlZW4oYWJzb2x1dGVSb290KX0gZm9yIFJlYWN0IGNvbXBvbmVudCBmaWxlcy4uLmApLnN0YXJ0KClcbiAgY29uc3QgZmlsZXMgPSBhd2FpdCBnZXRDb21wb25lbnRGaWxlcyhhYnNvbHV0ZVJvb3QpXG4gIHNwaW5uZXIuc3RvcCgpXG5cbiAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmxvZyhyZWQuYm9sZCgnTm8gY29tcG9uZW50cyBmb3VuZCEgOihcXG4nKSlcbiAgICBjb25zb2xlLmxvZyhgTWFrZSBzdXJlIHlvdSBhcmUgcnVubmluZyAke2N5YW4oJ2dlbmVyYWN0Jyl9IGluc2lkZSBhIFJlYWN0LWxpa2UgcHJvamVjdCBkaXJlY3Rvcnkgb3IgdXNpbmcgJHtncmVlbigncm9vdCcpfSBvcHRpb246XFxuYClcbiAgICBjb25zb2xlLmxvZyhgICAgICR7Y3lhbignJCBnZW5lcmFjdCcpfSAke2dyZWVuKCctLXJvb3QgcmVsYXRpdmUvb3IvYWJzb2x1dGUvcGF0aC90by9hbnkvcmVhY3QvcHJvamVjdCcpfVxcbmApXG4gICAgY29uc29sZS5sb2coYElmIHlvdSBhcmUgYWxyZWFkeSBkb2luZyB0aGF0LCBpdCBtZWFucyB0aGF0ICR7Y3lhbignZ2VuZXJhY3QnKX0gY291bGQgbm90IGZpbmQgeW91ciBSZWFjdCBjb21wb25lbnQgZmlsZXMgYXV0b21hZ2ljYWxseS5gKVxuICAgIGNvbnNvbGUubG9nKCdJbiB0aGlzIGNhc2UsIHlvdSBjYW4gZXhwbGljaXRseSBwYXNzIHRoZSBjb21wb25lbnQgcGF0aCB0byByZXBsaWNhdGU6XFxuJylcbiAgICBjb25zb2xlLmxvZyhgICAgICR7Y3lhbignJCBnZW5lcmFjdCcpfSAke2dyZWVuKCdyZWxhdGl2ZS9vci9hYnNvbHV0ZS9wYXRoL3RvL215L3JlYWN0L2NvbXBvbmVudC5qcycpfVxcbmApXG4gICAgcmV0dXJuIHByb2Nlc3MuZXhpdCgxKVxuICB9XG5cbiAgaW5xdWlyZXIucmVnaXN0ZXJQcm9tcHQoJ2F1dG9jb21wbGV0ZScsIGF1dG9jb21wbGV0ZSlcbiAgY29uc3QgYW5zd2VycyA9IGF3YWl0IGlucXVpcmVyLnByb21wdChbY29tcG9uZW50KGZpbGVzKV0pXG4gIHJldHVybiBhbnN3ZXJzLmNvbXBvbmVudFxufVxuXG5pZiAoY2xpLmlucHV0Lmxlbmd0aCkge1xuICBwZXJmb3JtUmVwbGljYXRpb24oY2xpLmlucHV0WzBdKVxufSBlbHNlIHtcbiAgc2NhbihjbGkuZmxhZ3Mucm9vdCkudGhlbihwZXJmb3JtUmVwbGljYXRpb24pXG59XG4iXX0=