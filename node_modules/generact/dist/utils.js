'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replicate = exports.replaceContents = exports.getComponentFiles = exports.getFiles = exports.isSingleFile = exports.getComponentFolder = exports.getComponentName = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _path = require('path');

var _lodash = require('lodash');

var _chalk = require('chalk');

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _listReactFiles = require('list-react-files');

var _listReactFiles2 = _interopRequireDefault(_listReactFiles);

var _fsExtra = require('fs-extra');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const removeExt = path => path.replace(/\.[^.]+$/, '');

const getComponentName = exports.getComponentName = path => path.split('/').reduce((name, part) => {
  if (/^[A-Z]/.test(part)) {
    return removeExt(part);
  } else if (/^((?!index).+)\.[^.]+$/.test(part)) {
    return (0, _lodash.upperFirst)((0, _lodash.camelCase)(removeExt(part)));
  }
  return name;
}, '');

const getComponentFolder = exports.getComponentFolder = path => {
  const name = getComponentName(path);
  return (0, _path.dirname)(path).split('/').reduce((folder, part) => {
    if (removeExt(part) === name) {
      return folder;
    }
    return (0, _path.join)(folder, part);
  }, './');
};

const isSingleFile = exports.isSingleFile = path => {
  const name = getComponentName(path);

  var _dirname$split$revers = (0, _path.dirname)(path).split('/').reverse(),
      _dirname$split$revers2 = _slicedToArray(_dirname$split$revers, 1);

  const dir = _dirname$split$revers2[0];


  return dir !== name;
};

const getFiles = exports.getFiles = (cwd, componentName) => {
  const extensions = '{js,ts,jsx,tsx,css,less,scss,sass,sss,json,md,mdx}';
  const pattern = componentName ? `**/${componentName}{.,.*.}${extensions}` : `**/*.${extensions}`;
  return _glob2.default.sync(pattern, { cwd, absolute: true, nodir: true });
};

const getComponentFiles = exports.getComponentFiles = (root, workingDir = process.cwd()) => (0, _listReactFiles2.default)(root).then(files => files.map(path => {
  const name = getComponentName(path);
  const absolutePath = (0, _path.join)(root, path);
  const relativePath = (0, _path.relative)(workingDir, absolutePath);
  return {
    name: `${name} ${(0, _chalk.gray)(relativePath)}`,
    short: name,
    value: absolutePath
  };
}));

const replaceContents = exports.replaceContents = (contents, oldName, newName) => contents.replace(new RegExp(`([^a-zA-Z0-9_$])${oldName}([^a-zA-Z0-9_$]|Container)|(['|"]./[a-zA-Z0-9_$]*?)${oldName}([a-zA-Z0-9_$]*?)`, 'g'), `$1$3${newName}$2$4`);

const replicate = exports.replicate = (() => {
  var _ref = _asyncToGenerator(function* (originalPath, answers, workingDir = process.cwd()) {
    const originalName = getComponentName(originalPath);
    const absolutePath = (0, _path.isAbsolute)(originalPath) ? originalPath : (0, _path.join)(workingDir, originalPath);

    const promises = [];

    if (isSingleFile(originalPath)) {
      const files = getFiles((0, _path.dirname)(absolutePath), originalName);

      files.forEach((() => {
        var _ref2 = _asyncToGenerator(function* (file) {
          const filename = (0, _path.basename)(file).replace(originalName, answers.name);
          const destinationPath = (0, _path.join)(workingDir, answers.folder, filename);
          const promise = (0, _fsExtra.copy)(file, destinationPath).then(function () {
            const contents = (0, _fsExtra.readFileSync)(destinationPath).toString();
            (0, _fsExtra.writeFileSync)(destinationPath, replaceContents(contents, originalName, answers.name));
          });
          promises.push(promise);
        });

        return function (_x3) {
          return _ref2.apply(this, arguments);
        };
      })());
    } else {
      const destinationPath = (0, _path.join)(workingDir, answers.folder, answers.name);
      yield (0, _fsExtra.copy)((0, _path.dirname)(absolutePath), destinationPath);
      const files = getFiles(destinationPath);

      files.forEach(function (file) {
        const contents = (0, _fsExtra.readFileSync)(file).toString();
        const renamedPath = (0, _path.join)((0, _path.dirname)(file), (0, _path.basename)(file).replace(originalName, answers.name));
        (0, _fsExtra.writeFileSync)(file, replaceContents(contents, originalName, answers.name));
        const promise = (0, _fsExtra.move)(file, renamedPath);
        promises.push(promise);
      });
    }
    yield Promise.all(promises);
  });

  return function replicate(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJyZW1vdmVFeHQiLCJwYXRoIiwicmVwbGFjZSIsImdldENvbXBvbmVudE5hbWUiLCJzcGxpdCIsInJlZHVjZSIsIm5hbWUiLCJwYXJ0IiwidGVzdCIsImdldENvbXBvbmVudEZvbGRlciIsImZvbGRlciIsImlzU2luZ2xlRmlsZSIsInJldmVyc2UiLCJkaXIiLCJnZXRGaWxlcyIsImN3ZCIsImNvbXBvbmVudE5hbWUiLCJleHRlbnNpb25zIiwicGF0dGVybiIsImdsb2IiLCJzeW5jIiwiYWJzb2x1dGUiLCJub2RpciIsImdldENvbXBvbmVudEZpbGVzIiwicm9vdCIsIndvcmtpbmdEaXIiLCJwcm9jZXNzIiwidGhlbiIsImZpbGVzIiwibWFwIiwiYWJzb2x1dGVQYXRoIiwicmVsYXRpdmVQYXRoIiwic2hvcnQiLCJ2YWx1ZSIsInJlcGxhY2VDb250ZW50cyIsImNvbnRlbnRzIiwib2xkTmFtZSIsIm5ld05hbWUiLCJSZWdFeHAiLCJyZXBsaWNhdGUiLCJvcmlnaW5hbFBhdGgiLCJhbnN3ZXJzIiwib3JpZ2luYWxOYW1lIiwicHJvbWlzZXMiLCJmb3JFYWNoIiwiZmlsZSIsImZpbGVuYW1lIiwiZGVzdGluYXRpb25QYXRoIiwicHJvbWlzZSIsInRvU3RyaW5nIiwicHVzaCIsInJlbmFtZWRQYXRoIiwiUHJvbWlzZSIsImFsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQSxNQUFNQSxZQUFZQyxRQUFRQSxLQUFLQyxPQUFMLENBQWEsVUFBYixFQUF5QixFQUF6QixDQUExQjs7QUFFTyxNQUFNQyw4Q0FBb0JGLElBQUQsSUFDOUJBLEtBQUtHLEtBQUwsQ0FBVyxHQUFYLEVBQWdCQyxNQUFoQixDQUF1QixDQUFDQyxJQUFELEVBQU9DLElBQVAsS0FBZ0I7QUFDckMsTUFBSSxTQUFTQyxJQUFULENBQWNELElBQWQsQ0FBSixFQUF5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b0JYLGdCQUFnQkMsUUFBaEIsRUFBMEJPLFlBQTFCLEVBQXdDRCxRQUFRbkMsSUFBaEQsQ0FBcEI7QUFDQSxjQUFNMEMsVUFBVSxtQkFBS0gsSUFBTCxFQUFXTSxXQUFYLENBQWhCO0FBQ0FSLGlCQUFTTyxJQUFULENBQWNGLE9BQWQ7QUFDRCxPQU5EO0FBT0Q7QUFDRCxVQUFNSSxRQUFRQyxHQUFSLENBQVlWLFFBQVosQ0FBTjtBQUNELEdBcENZOztBQUFBO0FBQUE7QUFBQTtBQUFBLElBQU4iLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGlzQWJzb2x1dGUsIGpvaW4sIHJlbGF0aXZlIH0gZnJvbSAncGF0aCdcbmltcG9ydCB7IGNhbWVsQ2FzZSwgdXBwZXJGaXJzdCB9IGZyb20gJ2xvZGFzaCdcbmltcG9ydCB7IGdyYXkgfSBmcm9tICdjaGFsaydcbmltcG9ydCBnbG9iIGZyb20gJ2dsb2InXG5pbXBvcnQgbGlzdFJlYWN0RmlsZXMgZnJvbSAnbGlzdC1yZWFjdC1maWxlcydcbmltcG9ydCB7IGNvcHksIG1vdmUsIHJlYWRGaWxlU3luYywgd3JpdGVGaWxlU3luYyB9IGZyb20gJ2ZzLWV4dHJhJ1xuaW1wb3J0IHR5cGUgeyBJbnF1aXJlckZpbGUgfSBmcm9tICcuL3R5cGVzJ1xuXG5jb25zdCByZW1vdmVFeHQgPSBwYXRoID0+IHBhdGgucmVwbGFjZSgvXFwuW14uXSskLywgJycpXG5cbmV4cG9ydCBjb25zdCBnZXRDb21wb25lbnROYW1lID0gKHBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiAoXG4gIHBhdGguc3BsaXQoJy8nKS5yZWR1Y2UoKG5hbWUsIHBhcnQpID0+IHtcbiAgICBpZiAoL15bQS1aXS8udGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIHJlbW92ZUV4dChwYXJ0KVxuICAgIH0gZWxzZSBpZiAoL14oKD8haW5kZXgpLispXFwuW14uXSskLy50ZXN0KHBhcnQpKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdChjYW1lbENhc2UocmVtb3ZlRXh0KHBhcnQpKSlcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVcbiAgfSwgJycpXG4pXG5cbmV4cG9ydCBjb25zdCBnZXRDb21wb25lbnRGb2xkZXIgPSAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUocGF0aClcbiAgcmV0dXJuIGRpcm5hbWUocGF0aCkuc3BsaXQoJy8nKS5yZWR1Y2UoKGZvbGRlciwgcGFydCkgPT4ge1xuICAgIGlmIChyZW1vdmVFeHQocGFydCkgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBmb2xkZXJcbiAgICB9XG4gICAgcmV0dXJuIGpvaW4oZm9sZGVyLCBwYXJ0KVxuICB9LCAnLi8nKVxufVxuXG5leHBvcnQgY29uc3QgaXNTaW5nbGVGaWxlID0gKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShwYXRoKVxuICBjb25zdCBbZGlyXSA9IGRpcm5hbWUocGF0aCkuc3BsaXQoJy8nKS5yZXZlcnNlKClcblxuICByZXR1cm4gZGlyICE9PSBuYW1lXG59XG5cbmV4cG9ydCBjb25zdCBnZXRGaWxlcyA9IChjd2Q6IHN0cmluZywgY29tcG9uZW50TmFtZT86IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9ucyA9ICd7anMsdHMsanN4LHRzeCxjc3MsbGVzcyxzY3NzLHNhc3Msc3NzLGpzb24sbWQsbWR4fSdcbiAgY29uc3QgcGF0dGVybiA9IGNvbXBvbmVudE5hbWUgPyBgKiovJHtjb21wb25lbnROYW1lfXsuLC4qLn0ke2V4dGVuc2lvbnN9YCA6IGAqKi8qLiR7ZXh0ZW5zaW9uc31gXG4gIHJldHVybiBnbG9iLnN5bmMocGF0dGVybiwgeyBjd2QsIGFic29sdXRlOiB0cnVlLCBub2RpcjogdHJ1ZSB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29tcG9uZW50RmlsZXMgPSAoXG4gIHJvb3Q6IHN0cmluZyxcbiAgd29ya2luZ0Rpcj86IHN0cmluZyA9IHByb2Nlc3MuY3dkKClcbik6IFByb21pc2U8SW5xdWlyZXJGaWxlW10+ID0+IChcbiAgbGlzdFJlYWN0RmlsZXMocm9vdCkudGhlbigoZmlsZXM6IHN0cmluZ1tdKSA9PlxuICAgIGZpbGVzLm1hcCgocGF0aDogc3RyaW5nKTogSW5xdWlyZXJGaWxlID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHBhdGgpXG4gICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBqb2luKHJvb3QsIHBhdGgpXG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSByZWxhdGl2ZSh3b3JraW5nRGlyLCBhYnNvbHV0ZVBhdGgpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBgJHtuYW1lfSAke2dyYXkocmVsYXRpdmVQYXRoKX1gLFxuICAgICAgICBzaG9ydDogbmFtZSxcbiAgICAgICAgdmFsdWU6IGFic29sdXRlUGF0aCxcbiAgICAgIH1cbiAgICB9KVxuICApXG4pXG5cbmV4cG9ydCBjb25zdCByZXBsYWNlQ29udGVudHMgPSAoXG4gIGNvbnRlbnRzOiBzdHJpbmcsXG4gIG9sZE5hbWU6IHN0cmluZyxcbiAgbmV3TmFtZTogc3RyaW5nXG4pOiBzdHJpbmcgPT4gY29udGVudHMucmVwbGFjZShcbiAgbmV3IFJlZ0V4cChgKFteYS16QS1aMC05XyRdKSR7b2xkTmFtZX0oW15hLXpBLVowLTlfJF18Q29udGFpbmVyKXwoWyd8XCJdLi9bYS16QS1aMC05XyRdKj8pJHtvbGROYW1lfShbYS16QS1aMC05XyRdKj8pYCwgJ2cnKSxcbiAgYCQxJDMke25ld05hbWV9JDIkNGBcbilcblxuZXhwb3J0IGNvbnN0IHJlcGxpY2F0ZSA9IGFzeW5jIChcbiAgb3JpZ2luYWxQYXRoOiBzdHJpbmcsXG4gIGFuc3dlcnM6IHsgbmFtZTogc3RyaW5nLCBmb2xkZXI6IHN0cmluZyB9LFxuICB3b3JraW5nRGlyPzogc3RyaW5nID0gcHJvY2Vzcy5jd2QoKVxuKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3JpZ2luYWxQYXRoKVxuICBjb25zdCBhYnNvbHV0ZVBhdGggPSBpc0Fic29sdXRlKG9yaWdpbmFsUGF0aCkgPyBvcmlnaW5hbFBhdGggOiBqb2luKHdvcmtpbmdEaXIsIG9yaWdpbmFsUGF0aClcblxuICBjb25zdCBwcm9taXNlcyA9IFtdXG5cbiAgaWYgKGlzU2luZ2xlRmlsZShvcmlnaW5hbFBhdGgpKSB7XG4gICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlcyhkaXJuYW1lKGFic29sdXRlUGF0aCksIG9yaWdpbmFsTmFtZSlcblxuICAgIGZpbGVzLmZvckVhY2goYXN5bmMgKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gYmFzZW5hbWUoZmlsZSkucmVwbGFjZShvcmlnaW5hbE5hbWUsIGFuc3dlcnMubmFtZSlcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uUGF0aCA9IGpvaW4od29ya2luZ0RpciwgYW5zd2Vycy5mb2xkZXIsIGZpbGVuYW1lKVxuICAgICAgY29uc3QgcHJvbWlzZSA9IGNvcHkoZmlsZSwgZGVzdGluYXRpb25QYXRoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29udGVudHMgPSByZWFkRmlsZVN5bmMoZGVzdGluYXRpb25QYXRoKS50b1N0cmluZygpXG4gICAgICAgIHdyaXRlRmlsZVN5bmMoZGVzdGluYXRpb25QYXRoLCByZXBsYWNlQ29udGVudHMoY29udGVudHMsIG9yaWdpbmFsTmFtZSwgYW5zd2Vycy5uYW1lKSlcbiAgICAgIH0pXG4gICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvblBhdGggPSBqb2luKHdvcmtpbmdEaXIsIGFuc3dlcnMuZm9sZGVyLCBhbnN3ZXJzLm5hbWUpXG4gICAgYXdhaXQgY29weShkaXJuYW1lKGFic29sdXRlUGF0aCksIGRlc3RpbmF0aW9uUGF0aClcbiAgICBjb25zdCBmaWxlcyA9IGdldEZpbGVzKGRlc3RpbmF0aW9uUGF0aClcblxuICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gcmVhZEZpbGVTeW5jKGZpbGUpLnRvU3RyaW5nKClcbiAgICAgIGNvbnN0IHJlbmFtZWRQYXRoID0gam9pbihkaXJuYW1lKGZpbGUpLCBiYXNlbmFtZShmaWxlKS5yZXBsYWNlKG9yaWdpbmFsTmFtZSwgYW5zd2Vycy5uYW1lKSlcbiAgICAgIHdyaXRlRmlsZVN5bmMoZmlsZSwgcmVwbGFjZUNvbnRlbnRzKGNvbnRlbnRzLCBvcmlnaW5hbE5hbWUsIGFuc3dlcnMubmFtZSkpXG4gICAgICBjb25zdCBwcm9taXNlID0gbW92ZShmaWxlLCByZW5hbWVkUGF0aClcbiAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSlcbiAgICB9KVxuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxufVxuIl19